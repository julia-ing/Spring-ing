# TDD 개념

## 1. TDD 란?

**Test Driven Development** : *테스트 주도 개발* : 테스트가 개발을 이끌어 나간다!

- 기존 방식 : 설계 이후 코드 개발, 테스트

    vs

- TDD : 테스트 코드 작성을 먼저하고, 이후 실제 코드 개발과 리팩토링 반복 

<img width="290" alt="스크린샷 2022-05-15 오전 11 47 25" src="https://user-images.githubusercontent.com/77239220/168454959-67f78fb0-2454-49cf-bf00-0275dde906a5.png">


> WHY TDD?

불확실성이 높을 때 “피드백”과 “협력”이 중요 (애자일)
	-> TDD 가 피드백과 협력을 증진

1. 피드백 – 테스트 코드의 성공 여부를 피드백으로 리팩토링
2. 협력 – 코드에 대한 문서 (실제 개발 코드에 대한 의도를 쉽게 파악 가능)

> WHEN TDD?

불확실성이 높을 때..

1.  처음 해보는 프로젝트 (나에 대한 불확실성)
2. 고객의 요구사항이 바뀔 수 있는 프로젝트 (외부적인 불확실성)
3. 개발하는 중에 코드를 많이 바꿔야 된다고 생각하는 경우
4. 내가 개발한 코드를 누가 유지보수할 지 모르는 경우


## 2. 단위 테스트와 통합 테스트

-  단위 테스트 (Unit Test) 

    - 하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 단위의 테스트, 자바에서는 JUnit 사용

        ```
        모듈? 
        애플리케이션에서 작동하는 하나의 기능 또는 메소드
        ```

- 통합 테스트(Integration Test) 

    - API 호출을 통해 모듈 통합 시 모듈끼리 잘 협력하는 지 확인

    - 프로젝트 내부의 스프링 빈을 모두 등록해 테스트에 필요한 의존성 추가 
        -> 실제 운영 환경과 가장 유사
    - 개발자가 변경할 수 없는 외부적인 환경에 대해서도 체크 가능 

    - 스프링부트에서는 @SpringBootTest 애노테이션 사용


> 단위 테스트의 필요성

통합 테스트는 여러 모듈들 간의 상호작용을 테스트하기 때문에 캐시나 디비 등 실제 연결이 필요함
-> 테스트를 위한 비용이 크다

반면 단위 테스트는 해당 부분만 독립적으로 테스트하기 때문에 특정 코드를 리팩토링해도 빠르게 문제 여부를 확인할 수 있게 됨

- 테스팅에 대한 시간과 비용 절감
- 새로운 기능 추가 시 수시로 빠르게 테스트 가능
- 리팩토링 시 안정성 확보
- 코드에 대한 문서가 될 수 있음


## 3. 레드-그린 사이클

- **RED** : 실패하는 테스트 코드를 작성
- **GREEN** : 테스트를 성공시키기 위한 실제 코드 작성
- **BLUE** : 중복 코드 제거, 일반화 등의 리팩토링

<img width="514" alt="스크린샷 2022-05-15 오전 11 38 27" src="https://user-images.githubusercontent.com/77239220/168454783-fd5831c5-3e70-4f33-b4e0-89df1eb8178a.png">

> 예시

    <생년월일(input)을 입력받으면 -> 현재 나이(output)를 출력하는 프로그램>

    1. 목표 설정 (태어난 해와 올해의 연도를 입력) : 2015, 2022 -> (만) 7살 
    2. 실제 코드를 짜기 전 항상 실패하는 테스트 설계  : 2015, 2022를 입력하면 5가 나오는 실패 테스트
    3. 위 테스트를 통과할 프로그램(1번을 목표로 작성한 코드) 작성 : 올해의 연도 - 태어난 해
    4. 테스트 코드 성공 여부 확인
    5. 통과했다면 새로운 테스트 추가 : Ex) 태어난 달을 추가했을 때 계산하는 프로그램


## 4. given-when-then

- **Given**
 테스트에서 구체화하고자 하는 행동을 시작하기 전, 테스트 상태 설명
- **When**
 구체화하고자 하는 행동
- **Then**
 특정 행동으로 인해 발생할 것이라고 예상되는 변화에 대한 설명

<img width="413" alt="스크린샷 2022-05-15 오전 11 37 33" src="https://user-images.githubusercontent.com/77239220/168454764-deae4a8b-8f61-4e26-90b1-aaffe70bdf2e.png">


## 5. 테스트 코드의 이점

- 보다 튼튼한 객체 지향적 코드 생산

    기능별로 철저하게 모듈화가 되기 때문에 나중에 모듈을 추가하거나 제거해도 소프트웨어 전체 구조에 영향을 미치지 않게 됨

- 재설계 시간 단축

    개발자가 개발을 할 때 지금 뭘 해야되는지 분명하게 정의하면서 개발을 할 수 있음 
    
    테스트 시나리오를 작성하면서 다양한 예외 사항에 대해서도 생각해볼 수 있기 때문에 나중에 실제 개발이 진행될 때 그때서야 소프트웨어의 전반적인 설계가 변경되는 일을 방지할 수가 있음

- 디버깅 시간 단축

    TDD는 단위 테스트를 전제하기 때문에 특정 버그를 쉽게 찾아낼 수 있음

- 테스트 문서의 대체 가능

    어떤 요소들이 테스트되었는지를 작성한 테스트 정의서를 테스트 코드로 대체 가능

- 추가 구현의 용이함

    객체 지향적 코드를 짤 수 있게 되므로 추가 기능을 구현이 수월해짐

*만약 테스트 코드를 작성하지 않는다면?*

    1. 코드 작성
    2. Tomcat 실행 후 Postman으로 HTTP 요청하여 요청 결과 확인
    3. 원하는 결과가 아닌 경우 Tomcat 중지하고 코드 수정
    4. 위 과정들 반복

-> 테스트코드를 작성하면 톰캣을 실행/중지할 필요 없이 로직이 잘 짜였는지 바로바로 확인 가능



## 6. JUnit

- 자바용 단위 테스트 프레임워크
- assert 메서드로 테스트 케이스의 수행 결과를 판별
- 애노테이션으로 간결하게 지원
- 최근 Junit5와 AssertJ라는 라이브러리를 같이 사용 (Junit 으로도 단위 테스트를 충분히 작성할 수 있지만 AssertJ 라이브러리에서 제공해주는 메서드들이 더 가독성이 좋고 다양)

## 7. 좋은 단위 테스트의 특징

- 1개의 테스트 함수에 대해 assert 최소화
- 1개의 테스트 함수는 1가지 개념만 테스트
 
- **<FIRST 규칙>** - “Clean Code”
    
    - Fast: 빠르게 동작
    - Independent: 각각의 테스트가 독립적 - 서로 의존하면 안됨
    - Repeatable: 어느 환경에서도 반복 가능
    - Self-Validating: 성공/실패 bool 값의 결과로 자체적 검증이 가능해야 함
    - Timely: 테스트하려는 실제 코드를 구현하기 직전에 구현
